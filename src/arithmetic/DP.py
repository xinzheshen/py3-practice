import numpy as np

# 如果一个奇葩国家的钞票面额分别是1、5、11，那么我们在凑出15的时候，贪心策略会出错：
# 　　15=1×11+4×1    （贪心策略使用了5张钞票）
# 　　15=3×5          正确的策略，只用3张钞票）　　
# 为什么会这样呢？贪心策略错在了哪里？　　鼠目寸光。　　
# 刚刚已经说过，贪心策略的纲领是：“尽量使接下来面对的w更小”。
# 这样，贪心策略在w=15的局面时，会优先使用11来把w降到4；
# 但是在这个问题中，凑出4的代价是很高的，必须使用4×1。
# 如果使用了5，w会降为10，虽然没有4那么小，但是凑出10只需要两张5元。　　
# 在这里我们发现，贪心是一种只考虑眼前情况的策略。
#
# 作者：阮行止
# 链接：https://www.zhihu.com/question/23995189/answer/613096905
# 来源：知乎

n = 15
f = np.zeros(n + 1)

for i in range(1, n+1):
    cost = float('inf')
    if i - 1 >= 0:
        cost = min(cost, f[i - 1] + 1)
    if i - 5 >= 0:
        cost = min(cost, f[i - 5] + 1)
    if i - 11 >= 0:
        cost = min(cost, f[i - 11] + 1)

    f[i] = cost
    print(f'f[{i}]={int(f[i])}')


# 最长上升子序列（LIS）问题：给定长度为n的序列a，从a中抽取出一个子序列，这个子序列需要单调递增。问最长的上升子序列（LIS）的长度。
# 　　e.g. 1,5,3,4,6,9,7,8的LIS为1,3,4,6,7,8，长度为6。

print("\n最长上升子序列（LIS）问题")
a = [1, 5, 3, 4, 6, 9, 7, 8]
n = len(a)
f = np.ones(n)

for i in range(n):
    for p in range(i):
        if a[p] < a[i]:
            f[i] = max(f[i], f[p] + 1)
    print(f'f[{i}]={int(f[i])}')

print(f.max())